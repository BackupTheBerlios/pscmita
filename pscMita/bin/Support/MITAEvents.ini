; *** Actions
; You may define some actions to be performed by MitaOrder after certain events occurred.
; Dependent on runtype (pre_PRODuction, pre_TEST or pre_DEVELOPment) they are defined like:
; [event]
; PROD,TEST,DEVELOP = action
; TEST = action
; DEVELOP,TEST,I_TEST = action
; pre is a combination of 'I', 'O', 'S'
; Here means I actions for pscMitaINP, O for pscMitaOLP and S for pscMitaSRV
; If the prefix is missing, IOP is assumed
; ...
; - runtype is set by switch when starting a Mita program. default is PROD
;
; Possible actions are:
; MAILTO! Sends an email
;       syntax: MAILTO! receiver|reference|text
;	receiver: standard email address format

; POPUP! Brings a message dialog up which disappears after the specified wait time if user did not react
:	Syntax: POPUP! message[|time]
;	if time is 0 or missing, it waits for ever

; ABORTORDER! Aborts processing of the actual order
;	Ad specs already processed remain stored in the third party system
; 	Additionally raises an event 'abortOrder' in the calling application
;	Syntax: ABORTORDER!

; ABORTMOTIV! Aborts processing of the actual ad spec
;	Syntax: ABORTMOTIV!

; ALARM! Makes an entry in the 'psconline' table in the field 'alarm'
;	Syntax: ALARM!Text

; BREAK! (For DEVELOP only) Stops the program at the place where the event occurred
;	Syntax: BREAK!

; RETRY! Writes a copy of the order marked as new input data, so the order will be processed again later
;	Syntax: RETRY! number
;	After 'number' retries are made w/o success retries are stopped
; 	!!!!! RETRY! must be the only action in an event
;       Actions for 'make retry' and 'max number exceeded' are made in [errorTrialsPossible] and [errorTrialsExceeded] 
;	RETRY! makes sense with pscMitaOLP only

; REQUERY! return value of raiseEvent tells the application to 'resume 0' or not
;       return values: MitaDef.mitaEventReturnCodes.requeryRequest and MitaDef.mitaEventReturnCodes.requeryExceeded
;	Syntax: REQUERY! number|milliseconds|[errortext[|errortext[|...]]]
; 	Before  MitaDef.mitaEventReturnCodes.requeryRequest is returned, the actions of 'errorRequeryYes' are done
;	When 'number' is exceeded, the 'errorRequeryNo' actions are done and MitaDef.mitaEventReturnCodes.requeryExceeded is returned
; 	if one or more errortexts are defined then the retry mechanism is done only for those errors which contain the errortext.
; 	the other errors return MitaDef.mitaRetryCodes.requeryExceeded at the first occurence

; UPDATEORDER! Makes an update in the pscordercontrol table
;	Syntax: UPDATEORDER! action 
; 	action: list of: field = value [|field = value ...]

; SAPERR! adds the item to RJHATERR tables
;	Syntax: SAPERR!text|type
;		text: SAP RJHATERR TecerrMsg
;		type: SAP RJHATERR TecerrTyp

; SAPSTAT! adds an entry to RJHATSTAT tables
; 	Syntax: SAPSTAT! label|entry

; LOGFILE! write a log entry to a file
; 	Syntax: LOGFILE! filename|text|max
; 		filename: complete path inclusive drive
;			or relative path to the application directory (starting with .\)
;		max: the log file is shortend by 100 lines if the file size exceeds max(in kByte)
;       	several log entries may be defined by multiple LOGFILE! definitions

; LOGDB! write a log entry to the psceventlog table in the data base
; 	Syntax: LOGDB! text|type|priority|comment
;		type: 'E' = Error; 'W' = Warning; 'L' = Normal process log; 'S' = SQL log
;		priority: integer number, default 0
;		comment: your comment text or a variable
;       	several log entries may be defined by multiple LOGDB! definitions

; ORDERTOFILE! Write the SAP order into file system
; 	Syntax: ORDERTOFILE! filename
; 		filename = complete path inclusive drive
;		or relative path starting from the application directory

; RAISE_END! raises an event 'endApplication(immediatelly as Boolean)' in the calling application
;	Syntax: RAISE_END! immediatelly 
;		immediatelly can be used to tell the application whether to end immediatelly
;		or shut down the application correctly and then end

; RAISE_LOG! raises an event 'logContent(logText as String, logType as string)' in the calling application
; 	Syntax: RAISE_LOG! text[|type]
;		type: 'E' = Error; 'W' = Warning; 'L' = Normal process log; 'S' = SQL log
;		Default type is 'L'

; RAISE_SAP!  	if the order has errors to be reported to SAP, raises an event 
;		'sapErrorForSend(cancel as Boolean, log as String)' in the calling application.
;		the errors are sent to SAP when cancel is false
;	Syntax: RAISE_SAP! [log]

; RAISE_EVENT1! raises an event 'userEvent1(parameter as String)' in the calling application
;	Syntax: RAISE_EVENT1! parameter

; RAISE_EVENT2! raises an event 'userEvent2(parameter as String)' in the calling application
;	Syntax: RAISE_EVENT2! parameter

; RAISE_EVENT3! raises an event 'userEvent3(parameter as String)' in the calling application
;	Syntax: RAISE_EVENT3! parameter|type

; ONLINELOGIN! 	reports the application as logged in in the psconline table
;	Syntax: ONLINELOGIN![mail address]
;		if the login is done w/o a logout before (program died or was killed),
;		a mail is sent to the specified address
;		including the last succesful processed order 
;		and the order beeing in process during program end
;		if mail adress is missing, the information is written into the file system

; ONLINELOGOUT! reports the application as logged out in the psconline table
;	Syntax: ONLINELOGOUT!

; ORDERSTART!	reports the actual order as started to process in the psconline table
;		should be raised by the application when an order is started to be processed
;	Syntax: ORDERSTART!

; ORDERFINISH!	reports the actual order as processed in the psconline table
;		should be raised by the application when an order has been processed
;	Syntax: ORDERFINISH!

; *** Variables
; Anywhere inside your action descriptions you may use these variables (if it makes sence)
; $ERRD$  Error description
; $ERRT$  Error type (number)
; $ERRC$  Error code (text)
; $ERRM$  module name where error occurred (should be for DEVELOPment only)
; $AVM$   Actual SAP order number
; $VNO$   Actual SAP order version number
; $MO$    Actual SAP motiv (AdSpec) number
; $PAPER$ Actual paper name (Item)
; $PSC$   Actual internal order ID (from pscordercontrol.pscid)
; $DATE$  Actual date as string
; $TIME$  Actual time as string
; $RTIM$  Total time to read the order
; $OTIM$  Total time to process the order
; $MTIM$  Total time to process the motiv (AdSpec)
; $ETIM$  Total time to send errors to SAP
; $INS$   Number of publish dates inserted
; $HOST$  Executing host name
; $ERROR$ Last error occurred
; $SIZE$  Size of the order (bytes)
; $GARB$  Number of unused AdSpecs skipped
; $$	  New line
;
; $ID$    Third party internal Application ID (to be set with 'namesSetId' when creating an instance of MitaOrder)
; $AD$    Actual Third party ad number
; $COMBO$ Actual Third party combination name (couple of sales) included in '()' or empty if no combination
; $ADVER$ Actual Third party ad version number
; $NUMAD$ Count of Third party ad numbers depending on actual order
; $ALLAD$ All Third party ad numbers depending on actual order (as one string)

; 	to use  $ID$, $AD$, $ADVER$ and $PAPER$ you must define them before from your application
;	if you do not define the value will be arbitrary, mostly 0 or NULL

; 	code like this:
;	...
; 	nextPRODMotiv
;	...
;       ' some code to retrieve or build ad number
;	sapOrder.infoSetAdNo adNumber
;	sapOrder.infoSetAdVer adVersion
;	...
;	for ComboNo = 0 to ComboCount
;	  sapOrder.infoSetComboNo comboNo
;	...

; *** samples

; You may define your own macros for abbreviations
[macros]
$STARTMO$=$DATE$ $TIME$ $AVM$$MO$($VNO$)
$START$=$DATE$ $TIME$ $AVM$($VNO$)
$SAP$=SAP Data corruped, no valid $ERRD$ record

[errorProgrammer]
comment = should only occur during DEVELOPment time; handle in the calling program
PROD,TEST,DEVELOP = POPUP! $ERRD$
PROD,TEST,DEVELOP = RAISE_END!

[errorUserIni]
comment = occurs when a value coming from SAP is not found in the lookup tables; correct tables entries
PROD,TEST,DEVELOP = POPUP! $ERRD$|20
PROD,TEST = SAPERR! $ERRD$|3
TEST,DEVELOP = ABORTORDER!

[errorSAPConnection]
comment = occurs when SAP connection cannot be made or is down
PROD,TEST,DEVELOP = POPUP! $ERRD$
PROD,TEST,DEVELOP = ALARM!$ERRD$
PROD,TEST,DEVELOP = RAISE_END!

[errorSAPVersion]
comment = occurs when an older version is processed 
PROD,TEST,DEVELOP = RAISE_LOG!$START$ Older version coming from SAP, skipped ($OTIM$ sec)|W
OS_PROD,OS_TEST,OS_DEVELOP = UPDATEORDER!processed = processed+1, status = 'V'|comments = 'Older version coming from SAP, skipped'|openid = NULL|closetime = sysdate|activ = 'N'
PROD,TEST,DEVELOP = ABORTORDER!

[errorSAPData]
comment = occurs when relevant SAP data are missing
OS_PROD,OS_TEST,OS_DEVELOP = SAPERR! $SAP$|3
PROD,TEST,DEVELOP = RAISE_LOG!$SAP$|E
PROD,TEST,DEVELOP = LOGDB!$SAP$|E
PROD,TEST,DEVELOP = ORDERTOFILE!ErrorOutput\$AVM$_$VNO$.err
OS_PROD,OS_TEST,OS_DEVELOP = UPDATEORDER!processed = processed+1, status = 'S'|comments = '$SAP$'|openhost = NULL|opentime = NULL|closetime = sysdate
PROD,TEST,DEVELOP = ABORTORDER!

[errorSAPReference]
comment = occurs when the referenced ad is not in the third party system
OS_PROD,OS_TEST,OS_DEVELOP = SAPERR! Could not find referenced ad in Sap2Atex table|3
OS_PROD,OS_TEST,OS_DEVELOP = LOGDB!Could not find referenced ad in Sap2Atex table|W|0|
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG!$START$ Could not find referenced ad in Sap2Atex table|W 

[errorFileSystem]
comment = occurs when problems with reading/writing orders from/to file system
PROD,TEST = LOGDB!Error accessing file $ERRD$|E|0|
DEVELOP = POPUP! Error accessing file $ERRD$ $ERRM$
PROD,TEST,DEVELOP = ALARM!Error accessing file $ERRD$
PROD,TEST = ABORTORDER!
DEVELOP = BREAK!

[errorDataBase]
comment = occurs when problems with reading/writing control data from/to data base
PROD,TEST,DEVELOP = POPUP! $ERRD$ $ERRM$
PROD,TEST,DEVELOP = RAISE_END

[errorNoOpenOrder]
comment = should only occur during DEVELOPment time; programmer error; handle in the calling program
TEST,DEVELOP = POPUP! $ERRD$
TEST,DEVELOP = RAISE_END!

[errorDatabaseSequence]
comment = occurs when next sequence number cannot be retreived from data base
PROD,TEST,DEVELOP = POPUP! Error returning next sequence number: $ERRD$|20
PROD,TEST = SAPERR! Error returning next sequence number: $ERRD$|3
PROD,TEST,DEVELOP = ALARM!Error returning next sequence number: $ERRD$
PROD,TEST,DEVELOP = ABORTORDER!

[errorDatabaseConnect]
comment = occurs when database connection has no success; either database is down or user/password/DSN is incorrect
PROD,TEST,DEVELOP = POPUP! $ERRD$
PROD,TEST,DEVELOP = ABORTORDER!
PROD,TEST,DEVELOP = ALARM!$ERRD$
PROD,TEST = RAISE_END!
DEVELOP = BREAK!

[errorNoActualSelect]
comment = should only occur during DEVELOPment time; programmer error; handle in the calling program
PROD,TEST,DEVELOP = POPUP! $ERRD$
PROD,TEST = RAISE_END!
DEVELOP = BREAK!

[errorNoRowsSelected]
comment = should only occur during DEVELOPment time; programmer error; handle in calling program
PROD,TEST,DEVELOP = POPUP! $ERRD$
PROD,TEST = RAISE_END!
DEVELOP = BREAK!

[errorInvalidInput]
comment = programmer error; either namesSetId or namesSetParentPath is not made; or one of them is an invalid string; handle in the calling program
PROD,TEST,DEVELOP = POPUP! $ERRD$
PROD,TEST = RAISE_END!
DEVELOP = BREAK!

[errorNoHost]
comment = user error; define HOSTNAME in the PCs environment
PROD,TEST,DEVELOP = POPUP! $ERRD$
PROD,TEST = RAISE_END!
DEVELOP = BREAK!

[errorLoop]
comment = occurs when the application starts and finds the same order two times unfinished
OS_PROD,OS_TEST,OS_DEVELOP = LOGDB!Order marked as problemous|E|1|Loop detected with orderID: $ERRD$
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG!$START$ Order Loop detected, Order marked as problemous
OS_PROD,OS_TEST,OS_DEVELOP = UPDATEORDER!processed = processed+1, status = 'L'|comments = 'Loop detected with orderID: $ERRD$'|openhost = NULL|opentime = NULL|closetime = sysdate

[errorTrialsExceeded]
comment = occurs when the number of retries exceeds the allowed number defined by RETRY!
OS_PROD,OS_TEST = SAPERR! $ERRD$|3
OS_PROD,OS_TEST,OS_DEVELOP = LOGDB!Order marked as problemous|E|1|Maximum number of retries reached: $PSC$
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG!$START$ Maximum number of retries reached, Order marked as problemous
OS_PROD,OS_TEST,OS_DEVELOP = UPDATEORDER!processed = processed+1, status = 'E'|comments = 'Maximum retries: $ERRD$'|openhost = NULL|opentime = NULL|closetime = sysdate
OS_PROD,OS_TEST = ORDERTOFILE! C:\MITA\LOGS\FromSap\$AVM$$MO$($VNO$).err
OS_PROD,OS_TEST,OS_DEVELOP = ABORTORDER!

[errorTrialsPossible]
comment = occurs when an order is copied for retry
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG! $DATE$ $TIME$ Retry because of error $ERRD$ with $AVM$$MO$($VNO$)|E
OS_PROD,OS_TEST = LOGDB!Retry because of error $ERRD$|E|1|
OS_PROD,OS_TEST,OS_DEVELOP = UPDATEORDER!processed = processed+1, status = 'R'|comments = '$ERRD$'|opentime = NULL|closetime = sysdate|activ = 'N'
OS_PROD,OS_TEST,OS_DEVELOP = ABORTORDER!
DEVELOP = POPUP!$ERRD$
DEVELOP = BREAK!

[programOrderRead]
comment = occurs when reading of new order starts
PROD,TEST,DEVELOP = ORDERSTART!
OS_PROD,OS_TEST,OS_DEVELOP = LOGDB!$START$ Order read, $SIZE$ bytes($OTIM$ sec)|L|0
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG!$START$ Order read, $SIZE$ bytes($OTIM$ sec)

[programOrderWritten]
comment = occurs when a new order has been stored into the data base or file
S_PROD,S_TEST,S_DEVELOP = RAISE_LOG!$START$ Order read and written to $ERRD$|L|0|
S_PROD,S_TEST,S_DEVELOP = LOGDB!Order read and written to $ERRD$|L|0|
I_PROD,I_TEST,I_DEVELOP = LOGDB!Order read and written to $ERRD$ in $OTIM$ sec|L|0|
I_PROD,I_TEST,I_DEVELOP = RAISE_LOG!$START$ Order read and written to $ERRD$ in $OTIM$ sec|L|0|
PROD,TEST,DEVELOP = ORDERFINISH!

[userSqlException]
comment = raised by the calling program when an error occured while writing to data base
O_PROD,O_TEST,O_DEVELOP = RETRY!3
S_PROD,S_TEST,S_DEVELOP = REQUERY!3|200|ORA-00001|ORA-00104|ORA-00099|ORA-00060|ORA-01756

[errorRequeryYes]
comment = try current query again
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG! $DATE$ $TIME$ Requery because of error $ERRD$ with $AVM$$MO$($VNO$)|E
OS_PROD,OS_TEST = LOGDB!Retry because of error $ERRD$|E|1|
DEVELOP = POPUP!$ERRD$

[errorRequeryNo]
comment = maximum number of current query is exceeded
S_PROD,S_TEST = SAPERR! $ERRD$|3
S_PROD,S_TEST,S_DEVELOP = LOGDB!Order marked as problemous|E|1|Maximum number of requeries reached: $PSC$
S_PROD,S_TEST,S_DEVELOP = RAISE_LOG!$START$ Maximum number of requeries reached, Order marked as problemous
S_PROD,S_TEST,S_DEVELOP = UPDATEORDER!processed = processed+1, status = 'E'|comments = 'Maximum requeries: $ERRD$'|openhost = NULL|opentime = NULL|closetime = sysdate
S_PROD,S_TEST = ORDERTOFILE! C:\MITA\LOGS\FromSap\$AVM$$MO$($VNO$).err
S_PROD,S_TEST,S_DEVELOP = ABORTORDER!

[userException1]
comment = raised by the calling program when ???, extention for user program work

[userException2]
comment = raised by the calling program when ???, extention for user program work

[userException3]
comment = raised by the calling program when ???, extention for user program work

[userMotivSuccess]
comment = to be raised from the calling program when adspec is successfully processed
OS_TEST,OS_DEVELOP = LOGDB!AdSpec done ($MTIM$ sec) >> ad $AD$, version $ADVER$|L|0|
OS_TEST,OS_DEVELOP = RAISE_LOG!$START$ AdSpec $MO$ Item $PAPER$$COMBO$ done ($MTIM$ sec) >> $AD$, vno $ADVER$

[userOrderSuccess]
comment = to be raised by the calling program when order is successfully processed
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_SAP!$START$ Errors sent to SAP ($ETIM$ sec)
OS_PROD,OS_TEST,OS_DEVELOP = LOGDB!Order done, $NUMAD$ Ads, $INS$ Schedule lines, skipped $GARB$ unused AdSpecs ($OTIM$ sec)|L|0|$ALLAD$
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG!$START$ Order done, $NUMAD$ Ads, $INS$ Schedule lines, skipped $GARB$ unused AdSpecs ($OTIM$ sec)
OS_PROD,OS_TEST,OS_DEVELOP = UPDATEORDER!processed = processed+1, status = 'D'|comments = '$ALLAD$'|openid = NULL|closetime = sysdate|activ = 'Y'
PROD,TEST,DEVELOP = ORDERFINISH!

[userOrderFailure]
comment = to be raised by the calling program when order is not processed because of an error
OS_PROD,OS_TEST = RAISE_SAP!$START$ Errors sent to SAP ($ETIM$ sec)
OS_PROD,OS_TEST = LOGDB!Order failed ($OTIM$ sec)|E|1|$ERROR$
OS_PROD,OS_TEST,OS_DEVELOP = RAISE_LOG!$START$ Order failed ($OTIM$ sec)
PROD,TEST,DEVELOP = ORDERFINISH!

[userLogSQL]
comment = to be raised from the calling program to log database actions
TEST,DEVELOP = LOGDB!$ERRD$|S|0|

[programStart]
comment = to be raised by the calling program when the application is starting
PROD = ONLINELOGIN! psc@exec-se.de
TEST = ONLINELOGIN!
DEVELOP = ONLINELOGIN!

[programEnd]
comment = to be raised by the calling program when ending the application
PROD,TEST,DEVELOP = ONLINELOGOUT!

